from sage.libs.gap.element import GapElement


def minimum_generating_set(G: GapElement) -> list:
    r"""
    INPUT:

        - ``G`` -- a finite group
        This must be converted to a
        'gap based' group via ``G=G.gap()`` if it's not.

    OUTPUT:

        - a minimum generating set of ``G``
        which is a set `g` of elements of `G` of
        smallest cardinality such that
        `G` is generated by `g`, i.e. `\braket{g}=G`.

    .. SEEALSO::

        :meth:`sage.categories.groups.Groups.ParentMethods.minimum_generating_set`

    ALGORITHM:

    First we cover the cases when we can use the ``MinimalGeneratingSet``
    method of GAP directly. This happens when `G` is either Simple,
    or Solvable, or Nilpotent.
    Then, if ``libgap.MinimalGeneratingSet`` fails, we proceed assuming
    that `G` is not a simple group.
    So, we are guaranteed to find a chief series of length at least 2.

    `S := ChiefSeries(G) = [G,G_1,G_2 \dots G_l]` where `G_l = \{e\}`

    Let `g` be the set of representatives of
    the minimum generating set of `G/G_1`.
    This can be found easily (since `G/G_1` is simple group) as
    ``g = libgap.MinimalGeneratingSet(GbyG1)``

    for k = 2 to l:

        Compute `G/G_k` , `G_{k-1}/G_k`

        `g := lift(g, (G_{k-1}/G_k) , (G/G_k) )`

        The `lift` function returns the
        (representatives of) minimum gnerating set
        of `G/G_k` given the (representatives of)
        minimum generating set of `G/G_{k-1}`.
        It is discussed later when it is encountered in code.

    return `g`

    TESTS:

    1. `A_5^7`
    ```
    sage: def A_5_to_n(n):
    ....:     A5 = AlternatingGroup(5).gap()
    ....:     G = A5
    ....:     for i in range(n-1):
    ....:         G = G.DirectProduct(A5)
    ....:     return G
    sage: G = A_5_to_n(7)
    sage: g = minimum_generating_set(G)
    sage: g
    [(1,5,4,3,2)(8,9,10)(12,14,13)(17,19,18)(22,24,23)(27,29,28)(32,34,33),
     (2,4,3)(6,8,10,7,9)(11,14,15,13,12)(16,19)(18,20)(21,25,24,22,23)(26,30,29,28,27)(31,35,34)]
    sage: %timeit g = minimum_generating_set(G)
    900 ms ± 90.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    ```
    2. `Z_3^10`
    ```
    sage: def Z_2_to_n(n):
    ....:     Z_2 =  PermutationGroup([(1,2)]).gap()
    ....:     G = Z_2
    ....:     for i in range(1,n):
    ....:         G = G.DirectProduct(Z_2)
    ....:     return G
    sage: G = Z_2_to_n(10)
    sage: g = minimum_generating_set(G)
    sage: len(g)
    10
    sage: g
    [(19,20),
     (17,18),
     (15,16),
     (13,14),
     (11,12),
     (9,10),
     (7,8),
     (5,6),
     (3,4),
     (1,2)]
    ```
    """
    assert isinstance(G, GapElement)
    if not G.IsFinite().sage():
        raise NotImplementedError("only implemented for finite groups")
    if (G.IsSimple().sage()
            or G.IsSolvable().sage()
            or G.IsNilpotentGroup().sage()):
        try:
            return list(libgap.MinimalGeneratingSet(G))
        except Exception as ex:
            pass

    def lift(
            G_by_Gim1_mingen_reps: list,
            Gim1_by_Gi: GapElement, G_by_Gi: GapElement,
            phi_G_by_Gi: GapElement, phi_Gim1_by_Gi: GapElement
    ) -> list:
        r"""
        Computes the minimum generating set
        (as representative elements) of
        a quotient group `G/G_i`
        in a chief series,
        given the minimum generating set
        (as representatives) of `G/G_{i-1}`,
        the factor group `G_{i-1}/G_i` and
        the quotient group `G/G_i` itself.

        INPUT:

            - ``G_by_Gim1_mingen_reps`` -- representative elements
            of the minimum generating set of `G/G_{i-1}`.
            We'll refer to it as `g = \{g_1,g_2,\dots g_s\}`
            for convenience throughout this
            algorithm's description (but not in the code).

            - ``G_by_Gim1`` --  The quotient Group `G / G_{i-1}`

            - ``Gim1_by_Gi`` --  The quotinet Group `G_{i-1} / G_i`

            - ``phi_G_by_Gi`` -- the natural homomorphism
            defining the cosets of `G_i` in `G`.

            - ``phi_Gim1_by_Gi`` -- the natural homomorphism
            defining the cosets of `G_i` in `G_{i-1}`.

        OUTPUT:

            representative elements of
            the minimum generating set of `G / G_{i}`.

        ALGORITHM:

            First, we compute some essential quantities:

            `\bold{n} :=\{n_1,n_2\dots n_k\}`
            where `\{n_1 G_i,n_2G_i \dots n_kG_{i}\}`
            is any generating set of `G_{i-1}/G_i ,
            i.e. it's the representative elements of
            any (prefferably small,
            but not necessarily minimal)
            generating set of `G_{i-1}/G_i`

            `\bold{N} := \{N_1,N_2\dots N_m\}`
            where `G_{i-1}/G_i = \{N_1G_i,N_2G_2\dots N_m G_m\}`.
            This is simply a list of
            representative elements of `G_{i-1}/G_i`.

            We wish to find the representatives of
            a minimum generating set of `G/G_i`.
            Here, we have two cases to consider.

            1.
            if `G_{i-1}/G_i` is abelian :

                if `\braket{gG_i}= G/G_i` :

                    return `g`

                for `1 \le p \le s`  and `n_j \in \bold{n}` :

                    `g^* = \{g_1,g_2\dots g_{p-1} ,g_p n_j,g_{p_1},\dots\}`

                    if `\braket{g^* G_i} = G/G_i` :

                        return `g^*`

            2.
            else:

                for any
                (not necessarily distinct)
                elements `N_{i_1},N_{i_2}\dots N_{i_t} \in \bold{N}`:

                    `g^* = \{g_1N_{i_1},g_{i_2}N_{i_3}\dots`
                    `g_{i_t}N_t,g_{t+1}\dots g_s\}`

                    if `\braket{g^*G_i}\; = G/G_i`:

                        return `{g^*}`

                for any
                (not necessarily distinct) elements
                `N_{i_1},N_{i_2}\dots N_{i_t} N_{i_{t+1}} \in \bold{N}`:

                    `g^* =`
                    `\{g_1N_{i_1},g_{i_2}N_{i_3}\dots`
                    `g_{i_t}N_t,g_{t+1}\dots g_s\}`

                    if `\braket{g^*G_i}\; = G/G_i`:

                        return `{g^*}`

            By now, we must have exhausted our search.

            """
        def gen_combinations(g: list, N: list, t: int):
            r"""
            Generates all modifications to `g` of form
            `g^* = \{g_1 N_1,g_2 N_2 \dots g_t N_t , g_{t+1}, g_{t+2} \dots\}`

            INPUT:

                - ``g`` -- a list of elements from some group `G`

                - ``N`` -- a list of elements of
                normal subgroup `N` of `G`

                - ``t`` -- the index till which to modify ``g``
            """
            if t == 0:
                yield g
                return
            for gm in gen_combinations(g, N, t-1):
                for n in N:
                    old = gm[t-1]
                    gm[t-1] = old * n
                    yield gm
                    gm[t-1] = old
        s = len(G_by_Gim1_mingen_reps)
        Gim1_by_Gi_L = list(Gim1_by_Gi.AsList())
        Gim1_by_Gi_elem_reps = [
            phi_Gim1_by_Gi.PreImagesRepresentative(x) for x in Gim1_by_Gi_L]
        Gim1_by_Gi_gen = list(libgap.SmallGeneratingSet(Gim1_by_Gi))
        Gim1_by_Gi_gen_reps = [
            phi_Gim1_by_Gi.PreImagesRepresentative(x) for x in Gim1_by_Gi_gen]
        if Gim1_by_Gi.IsAbelian().sage():
            if (G_by_Gi == libgap.GroupByGenerators(
                [phi_G_by_Gi.ImagesRepresentative(x)
                 for x in G_by_Gim1_mingen_reps])):
                return G_by_Gim1_mingen_reps
            for i in range(s):
                for j in range(len(Gim1_by_Gi_gen_reps)):
                    temp = G_by_Gim1_mingen_reps[i]
                    G_by_Gim1_mingen_reps[i] = G_by_Gim1_mingen_reps[i] * \
                        Gim1_by_Gi_gen_reps[j]
                    if (G_by_Gi == libgap.GroupByGenerators(
                        [phi_G_by_Gi.ImagesRepresentative(x)
                         for x in G_by_Gim1_mingen_reps])):
                        return G_by_Gim1_mingen_reps
                    G_by_Gim1_mingen_reps[i] = temp
            return G_by_Gim1_mingen_reps + [Gim1_by_Gi_gen_reps[0]]
        for raw_gens in gen_combinations(
                G_by_Gim1_mingen_reps,
                Gim1_by_Gi_elem_reps, s):
            if (G_by_Gi == libgap.GroupByGenerators(
                [phi_G_by_Gi.ImagesRepresentative(x)
                 for x in raw_gens])):
                return raw_gens
        for raw_gens in gen_combinations(
                G_by_Gim1_mingen_reps+[Gim1_by_Gi_elem_reps[0]],
                Gim1_by_Gi_elem_reps, s+1):
            if (G_by_Gi == libgap.GroupByGenerators(
                [phi_G_by_Gi.ImagesRepresentative(x)
                 for x in raw_gens])):
                return raw_gens
    cs = G.ChiefSeries()
    phi_GbyG1 = G.NaturalHomomorphismByNormalSubgroup(cs[1])
    GbyG1 = phi_GbyG1.ImagesSource()
    mingenset_k_reps = [phi_GbyG1.PreImagesRepresentative(x) for x in list(
        libgap.SmallGeneratingSet(GbyG1))]  # k=1 initially
    for k in range(2, len(cs)):
        mingenset_km1_reps = mingenset_k_reps
        Gk, Gkm1 = cs[k], cs[k-1]
        phi_GbyGk = G.NaturalHomomorphismByNormalSubgroup(Gk)
        GbyGk = phi_GbyGk.ImagesSource()
        phi_Gkm1byGk = Gkm1.NaturalHomomorphismByNormalSubgroup(Gk)
        Gkm1byGk = phi_Gkm1byGk.ImagesSource()
        mingenset_k_reps = lift(
            mingenset_km1_reps, Gkm1byGk, GbyGk, phi_GbyGk, phi_Gkm1byGk)
    assert (G == libgap.GroupByGenerators(mingenset_k_reps))
    return mingenset_k_reps
