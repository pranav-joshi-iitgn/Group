#############################################################################
##
#M  MinimalGeneratingSetUsingChiefSeries( <G> )
##
#  This algorithm is described in the paper
#  "The Minimum Generating Set Problem" by Dhara Thakar and Andrea Lucchini.
#  link : https://arxiv.org/abs/2306.07633
BindGlobal("MinimalGeneratingSetUsingChiefSeries",function(G)
    local
      cs, # The chief series of G
      check, # A function to check if GbyGk is generated by cosets with given representative
      GbyGk, # The quotient group of G with the k+1 st group in its chief series (1st is G)
      Gkm1byGk, # Quotient of the kth and k-1 th groups in chief series of G.
      Gkm1byGk_elem_reps, # The coset representatives of Gkm1byGk
      Gkm1byGk_gen, # A (small) generating set of Gkm1byGk
      Gkm1byGk_gen_reps, # The coset representatives (CR) of elements Gkm1byGk_gen
      mingenset_k_reps, # The CR of minimum generating set (MGS) of GbyGkm1
      phi_GbyG1, # Homomorphism for quotient group GbyG1
      GbyG1, # Quotient of G and 2nd group in its chief series
      phi_GbyGk, # Homomorphism for quotient group GbyG1
      phi_Gkm1byGk, # Homomorphism for quotient group Gkm1byGk
      temp,i,j,l,L,x,xl,y,prev,gmod,N,g,g0,g1,s,r,stop,k;
    cs := ChiefSeries(G);
    phi_GbyG1 := NaturalHomomorphismByNormalSubgroup(G,cs[2]);
    GbyG1 := ImagesSource(phi_GbyG1);
    mingenset_k_reps := List(MinimalGeneratingSet(GbyG1), x -> PreImagesRepresentative(phi_GbyG1, x));
    # GbyG1 is a simple group, so it has a 2 size generating set which can be found easily.
    # I'll rely on MinimalGeneratingSet to do this.
    check := gx -> GbyGk = GroupByGenerators(ImagesSet(phi_GbyGk,gx));
    for k in [3..Length(cs)] do # Lifting
      # We wish to compute the CR of MGS of GbyGk, given the CR of MGS of GbyGkm1 .
      phi_GbyGk := NaturalHomomorphismByNormalSubgroup(G,cs[k]);
      GbyGk := ImagesSource(phi_GbyGk);
      if check(mingenset_k_reps) then break; fi;
      phi_Gkm1byGk := NaturalHomomorphismByNormalSubgroup(cs[k-1],cs[k]);
      Gkm1byGk := ImagesSource(phi_Gkm1byGk);
      Gkm1byGk_gen := SmallGeneratingSet(Gkm1byGk);
      Gkm1byGk_gen_reps := List(Gkm1byGk_gen,x -> PreImagesRepresentative(phi_Gkm1byGk,x));
      g := ShallowCopy(mingenset_k_reps);
      stop := false;
      if IsAbelian(Gkm1byGk) then
        for i in [1..Length(g)] do
          if stop then break; fi;
          for j in [1..Length(Gkm1byGk_gen_reps)] do
            temp := g[i];
            g[i] := temp * Gkm1byGk_gen_reps[j];
            if check(g) then
              mingenset_k_reps := g;
              stop := true;
              break;
            fi;
            g[i] := temp;
          od;
        od;
        if not stop then
          Add(g,Gkm1byGk_gen_reps[1]);
          Assert(1,check(g),"The algorithm is failing");
          mingenset_k_reps := g;
        fi;
      else
        Gkm1byGk_elem_reps := List(Enumerator(Gkm1byGk),x -> PreImagesRepresentative(phi_Gkm1byGk,x));
        g0 := ShallowCopy(mingenset_k_reps);
        g1 := ShallowCopy(mingenset_k_reps);  
        Add(g1,Gkm1byGk_elem_reps[1]);
        for g in [g0,g1] do
          if stop then break;fi;
          l := Length(g);
          L := Length(Gkm1byGk_elem_reps);
          s := L^l;
          prev := [];
          for i in [l,l-1..1] do prev[i] := 1; od;
          gmod := ShallowCopy(g);
          for x in [0..s-1] do
            xl := [];
            for i in [1..l] do xl[i] := 0; od;
            i := 1;
            while x > 0 do
              r := RemInt(x,L);
              x := QuoInt(x,L);
              xl[i]:=r;
              i:= i+1;
            od;
            for i in [1..l] do
              if xl[i] <> prev[i] then
                gmod[i] := g[i] * Gkm1byGk_elem_reps[xl[i]+1];
              fi;
            od;
            if check(gmod) then
              mingenset_k_reps := gmod;
              stop := true;
              break;
            fi;
            prev := xl;
          od;
        od;
      fi;
    od;
    Assert(1,G = GroupByGenerators(mingenset_k_reps),"The algorithm is failing");
    return mingenset_k_reps;
end);


# ---------------- Methods Already there in GAP ----------------------------


InstallMethod( MinimalGeneratingSet,"finite cyclic groups",true,
    [ IsGroup and IsCyclic and IsFinite ],
    {} -> RankFilter(IsFinite and IsPcGroup),
function ( G )
local g;
  if IsTrivial(G) then return []; fi;
  g:=Product(IndependentGeneratorsOfAbelianGroup(G),One(G));
  Assert( 1, Index(G,Subgroup(G,[g])) = 1 );
  return [g];
end);

#############################################################################
##
#M  MinimalGeneratingSet(<G>) . . . . . . . . . . . . . for groups
##
InstallMethod(MinimalGeneratingSet,"test solvable and 2-generator noncyclic",
  true, [IsGroup and IsFinite],0,
function(G)
  if not HasIsSolvableGroup(G) and IsSolvableGroup(G) and
     CanEasilyComputePcgs(G) then
    # discovered solvable -- redo
    return MinimalGeneratingSet(G);
  elif not IsSolvableGroup(G) then
    if IsGroup(G) and (not IsCyclic(G)) and HasGeneratorsOfGroup(G)
        and Length(GeneratorsOfGroup(G)) = 2 then
      return GeneratorsOfGroup(G);
    fi;
  fi;
  TryNextMethod();
end);

#############################################################################
##
#M  MinimalGeneratingSet(<G>)
##
InstallOtherMethod(MinimalGeneratingSet,"fallback method to inform user",true,
  [IsObject],0,
function(G)
  if IsGroup(G) and IsSolvableGroup(G) then
    TryNextMethod();
  elif IsGroup(G) and IsFinite(G) then
    return MinimalGeneratingSetUsingChiefSeries(G);
  else
    Error("MinimalGeneratingSet assumes that input group is",
    "finite or solvable or already has a generating set of 2 elements");
  fi;
end);


# ----------------------- Method for all finite groups in GAP ----------------

InstallOtherMethod(MinimalGeneratingSet,"finite groups",true,
  [IsGroup and IsFinite],0,
function(g)
local r,i,j,u,f,q,n,lim,sel,nat,ok,mi;
  if not HasIsSolvableGroup(g) and IsSolvableGroup(g) and
     CanEasilyComputePcgs(g) then
    return MinimalGeneratingSet(g);
  fi;
  # start at rank 2/abelian rank
  n:=AbelianInvariants(g);
  if Length(n)>0 then
    r:=Maximum(List(Set(List(n,SmallestPrimeDivisor)),
      x->Number(n,y->y mod x=0)));
  else r:=0; fi;
  r:=Maximum(r,2);
  n:=false;
  repeat
    if Length(GeneratorsOfGroup(g))=r then
      return GeneratorsOfGroup(g);
    fi;
    for i in [1..10^r] do
      u:=SubgroupNC(g,List([1..r],x->Random(g)));
      if Size(u)=Size(g) then return GeneratorsOfGroup(u);fi; # found
    od;
    f:=FreeGroup(r);
    ok:=false;
    if not IsSolvableGroup(g) then
      if n=false then
        n:=ShallowCopy(NormalSubgroups(g));
        if IsPerfectGroup(g) then
          # all perfect groups of order <15360 *are* 2-generated
          lim:=15360;
        else
          # all groups of order <8 *are* 2-generated
          lim:=8;
        fi;
        n:=Filtered(n,x->IndexNC(g,x)>=lim and Size(x)>1);
        SortBy(n,x->-Size(x));
        mi:=MinimalInclusionsGroups(n);
      fi;
      i:=1;
      while i<=Length(n) do
        ok:=false;
        # is factor randomly r-generated?
        q:=2^r;
        while ok=false and q>0 do
          u:=n[i];
          for j in [1..r] do
            u:=ClosureGroup(u,Random(g));
          od;
          ok:=Size(u)=Size(g);
          q:=q-1;
        od;

        if not ok then
          # is factor a nonsplit extension with minimal normal -- if so rank
          # stays the same, no new test

          # minimal overnormals
          sel:=List(Filtered(mi,x->x[1]=i),x->x[2]);
          if Length(sel)>0 then
            nat:=NaturalHomomorphismByNormalSubgroupNC(g,n[i]);
            for j in sel do
              if not ok then
                # nonsplit extension (so pre-images will still generate)?
                ok:=0=Length(
                  ComplementClassesRepresentatives(Image(nat),Image(nat,n[j])));
              fi;
            od;
          fi;
        fi;

        if not ok then
          q:=GQuotients(f,g/n[i]:findall:=false);
          if Length(q)=0 then
            # fail in quotient
            i:=Length(n)+10;
            Info(InfoGroup,2,"Rank ",r," fails in quotient\n");
          fi;
        fi;

        i:=i+1;
      od;

    fi;
    if n=false or i<=Length(n)+1 then
      # still try group
      q:=GQuotients(f,g:findall:=false);
      if Length(q)>0 then return r;fi; # found
    fi;
    r:=r+1;
  until false;
end);